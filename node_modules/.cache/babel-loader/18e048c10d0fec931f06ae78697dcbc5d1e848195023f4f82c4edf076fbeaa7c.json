{"ast":null,"code":"var _jsxFileName = \"/Users/giuseppebondi/Documents/GitHub/platform/src/components/EmuSchermo.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  LEFT: 7,\n  RIGHT: 8\n};\nfunction createSeededRandom(seed) {\n  const a = 1664526;\n  const c = 1113914222;\n  const m = 2 ** 33;\n  let state = seed;\n  return function () {\n    state = (a * state + c) % m;\n    return state / m;\n  };\n}\nfunction generateLevel(seed) {\n  const rand = createSeededRandom(seed);\n  const platforms = [];\n  const maxX = 100;\n  // Parametri di generazione:\n  const N = rand() * 13; // numero totale di piattaforme (l'ultima sarà quella \"bianca\" di tipo \"T\")\n  const minWidth = 5;\n  const maxWidth = 30;\n  const minVertical = 5;\n  const maxVertical = 13;\n  const minGap = 2; // gap orizzontale minimo\n  const maxGap = 13; // gap orizzontale massimo\n\n  // Genera la prima piattaforma (base)\n  const baseHeight = 20;\n  const firstWidth = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n  const firstPosStartX = Math.floor(rand() * (maxX - firstWidth));\n  const firstPosEndX = firstPosStartX + firstWidth;\n  platforms.push({\n    type: 'p',\n    height: baseHeight,\n    posStartX: firstPosStartX,\n    posEndX: firstPosEndX\n  });\n  let prev = platforms[0];\n\n  // Genera le piattaforme intermedie\n  for (let i = 1; i < N; i++) {\n    // Incremento verticale controllato\n    const verticalIncrement = Math.floor(rand() * (maxVertical - minVertical + 1)) + minVertical;\n    const newHeight = prev.height + verticalIncrement;\n    // Larghezza della nuova piattaforma\n    const width = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n    // Scegli gap e direzione (1 = a destra, -1 = a sinistra)\n    let gap = Math.floor(rand() * (maxGap - minGap + 1)) + minGap;\n    let direction = rand() < 0.5 ? 1 : -1;\n    let posStartX;\n    if (direction === 1) {\n      // Prova a posizionare a destra della precedente\n      if (prev.posEndX + gap + width <= maxX) {\n        posStartX = prev.posEndX + gap;\n      } else if (prev.posStartX - gap - width >= 0) {\n        // Se non c'è spazio a destra, prova a sinistra\n        direction = -1;\n        posStartX = prev.posStartX - gap - width;\n      } else {\n        // Forza il posizionamento in caso di spazio ristretto\n        posStartX = Math.max(0, maxX - width);\n      }\n    } else {\n      // Prova a posizionare a sinistra della precedente\n      if (prev.posStartX - gap - width >= 0) {\n        posStartX = prev.posStartX - gap - width;\n      } else if (prev.posEndX + gap + width <= maxX) {\n        // Se non c'è spazio a sinistra, prova a destra\n        direction = 1;\n        posStartX = prev.posEndX + gap;\n      } else {\n        posStartX = 0;\n      }\n    }\n    const posEndX = posStartX + width;\n\n    // Se è l'ultima piattaforma, forziamo il tipo \"T\" (la piattaforma bianca)\n    let type = i === N ? \"T\" : \"p\";\n    // Per le intermedie, aggiungiamo la possibilità di avere spike (tipo \"s\")\n    if (type === \"p\" && rand() < 0.3) {\n      type = \"s\";\n    }\n    const platform = {\n      type,\n      height: newHeight,\n      posStartX,\n      posEndX\n    };\n    platforms.push(platform);\n    prev = platform;\n  }\n  return platforms;\n}\nfunction EmuSchermo({\n  pressedButtons\n}) {\n  _s();\n  const ballSize = 4;\n  const horizontalAcceleration = 0.1;\n  const maxHorizontalSpeed = 1;\n  const friction = 0.2;\n  const jumpVelocity = 6;\n  const gravity = -0.5;\n  const [level, setLevel] = useState(1);\n  const [LEVEL, SETLEVEL] = useState(generateLevel(1));\n  const platformsRef = useRef(LEVEL);\n  useEffect(() => {\n    platformsRef.current = LEVEL;\n  }, [LEVEL]);\n  const [ball, setBall] = useState({\n    x: 2,\n    y: 0,\n    vx: 0,\n    vy: 0\n  });\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n  const animationFrameId = useRef(null);\n  useEffect(() => {\n    const update = () => {\n      setBall(prev => {\n        let {\n          x,\n          y,\n          vx,\n          vy\n        } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione input orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) vx -= horizontalAcceleration;\n        if (currentPressedButtons[BUTTONS.RIGHT]) vx += horizontalAcceleration;\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          vx = vx > 0 ? Math.max(vx - friction, 0) : Math.min(vx + friction, 0);\n        }\n        vx = Math.min(Math.max(vx, -maxHorizontalSpeed), maxHorizontalSpeed);\n\n        // Salto solo se a terra o su piattaforma\n        const isOnGroundOrPlatform = prev.y === 0 || platformsRef.current.some(p => {\n          const platformTop = p.height + 2;\n          const horizontalOverlap = prev.x <= p.posEndX && prev.x + ballSize >= p.posStartX;\n          return prev.y === platformTop && horizontalOverlap;\n        });\n        if (currentPressedButtons[BUTTONS.A] && isOnGroundOrPlatform) {\n          vy = jumpVelocity;\n        }\n        vy += gravity;\n        let newY = y + vy;\n        let newX = x + vx;\n\n        // Collisioni con piattaforme\n        let collided = false;\n        platformsRef.current.forEach(platform => {\n          const platformTop = platform.height + 2; // Top della piattaforma (2% di spessore)\n          const platformBottom = platform.height; // Base della piattaforma\n\n          // 1. Controllo overlap orizzontale\n          const horizontalOverlap = newX < platform.posEndX && newX + ballSize > platform.posStartX;\n\n          // 2. Controllo overlap verticale\n          const verticalOverlap = newY <= platformTop && newY + ballSize >= platformBottom;\n\n          // 3. Determinazione direzione collisione\n          if (horizontalOverlap && verticalOverlap) {\n            const prevBottom = prev.y + ballSize;\n            if (prevBottom <= platformBottom && vy > 0) {\n              // Collisione dal basso (salto contro piattaforma)\n              newY = platformBottom - ballSize;\n              vy = 0;\n            } else if (vy <= 0) {\n              // Collisione dall'alto (atterraggio su piattaforma)\n              newY = platformTop;\n              vy = 0;\n            }\n            collided = true;\n          }\n        });\n\n        // Collisione con il terreno solo se non abbiamo colliso con piattaforme\n        if (!collided && newY < 0) {\n          newY = 0;\n          vy = 0;\n        }\n\n        // Clamping orizzontale\n        newX = Math.max(0, Math.min(newX, 100 - ballSize));\n        platformsRef.current.forEach(platform => {\n          if (platform.type === \"s\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeTop = platform.height + 3;\n            const spikeBottom = platform.height;\n            const horizontalCollision = x + ballSize > spikeLeft && x < spikeRight;\n            const verticalCollision = y < spikeTop && y + ballSize > spikeBottom && vy <= 0;\n            if (horizontalCollision && verticalCollision) {\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n              SETLEVEL(generateLevel(level));\n            }\n          }\n          if (platform.type === \"T\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeTop = platform.height + 3;\n            const spikeBottom = platform.height + 2;\n            const horizontalCollision = x + ballSize > spikeLeft && x < spikeRight;\n            const verticalCollision = y < spikeTop && y + ballSize > spikeBottom && vy <= 0;\n            if (horizontalCollision && verticalCollision) {\n              const newLevel = level + 1;\n              setLevel(newLevel);\n              SETLEVEL(generateLevel(newLevel)); // Aggiorna lo stato correttamente\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n            }\n          }\n        });\n        return {\n          x: newX,\n          y: newY,\n          vx,\n          vy\n        };\n      });\n      animationFrameId.current = requestAnimationFrame(update);\n    };\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [level, ballSize, horizontalAcceleration, friction, maxHorizontalSpeed, jumpVelocity, gravity]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"emu-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"ball\",\n      style: {\n        left: `${ball.x}%`,\n        bottom: `${ball.y}%`,\n        width: `${ballSize}%`,\n        height: `${ballSize + 2}%`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 280,\n      columnNumber: 7\n    }, this), LEVEL.map((item, i) => {\n      if (item.type === \"T\") {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"t-platform\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 13\n        }, this);\n      } else if (item.type === \"p\") {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"platform\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 306,\n          columnNumber: 13\n        }, this);\n      } else {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"spike\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 319,\n          columnNumber: 13\n        }, this);\n      }\n    })]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 279,\n    columnNumber: 5\n  }, this);\n}\n_s(EmuSchermo, \"W9HxADwyY9lDZR10Sc6DM7DCH8k=\");\n_c = EmuSchermo;\nexport default EmuSchermo;\nvar _c;\n$RefreshReg$(_c, \"EmuSchermo\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","BUTTONS","A","B","START","SELECT","LEFT","RIGHT","createSeededRandom","seed","a","c","m","state","generateLevel","rand","platforms","maxX","N","minWidth","maxWidth","minVertical","maxVertical","minGap","maxGap","baseHeight","firstWidth","Math","floor","firstPosStartX","firstPosEndX","push","type","height","posStartX","posEndX","prev","i","verticalIncrement","newHeight","width","gap","direction","max","platform","EmuSchermo","pressedButtons","_s","ballSize","horizontalAcceleration","maxHorizontalSpeed","friction","jumpVelocity","gravity","level","setLevel","LEVEL","SETLEVEL","platformsRef","current","ball","setBall","x","y","vx","vy","pressedButtonsRef","animationFrameId","update","currentPressedButtons","min","isOnGroundOrPlatform","some","p","platformTop","horizontalOverlap","newY","newX","collided","forEach","platformBottom","verticalOverlap","prevBottom","spikeLeft","spikeRight","spikeTop","spikeBottom","horizontalCollision","verticalCollision","newLevel","requestAnimationFrame","cancelAnimationFrame","className","children","style","left","bottom","fileName","_jsxFileName","lineNumber","columnNumber","map","item","_c","$RefreshReg$"],"sources":["/Users/giuseppebondi/Documents/GitHub/platform/src/components/EmuSchermo.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\n\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  LEFT: 7,\n  RIGHT: 8,\n};       \nfunction createSeededRandom(seed) {\n  const a = 1664526;\n  const c = 1113914222;\n  const m = 2 ** 33;\n  let state = seed;\n  return function () {\n    state = (a * state + c) % m;\n    return state / m;\n  };\n}\n\nfunction generateLevel(seed) {\n  const rand = createSeededRandom(seed);\n  const platforms = [];\n  const maxX = 100;\n  // Parametri di generazione:\n  const N = rand() *13 ;         // numero totale di piattaforme (l'ultima sarà quella \"bianca\" di tipo \"T\")\n  const minWidth = 5;\n  const maxWidth = 30;\n  const minVertical = 5;\n  const maxVertical = 13;\n  const minGap = 2;     // gap orizzontale minimo\n  const maxGap = 13;    // gap orizzontale massimo\n\n  // Genera la prima piattaforma (base)\n  const baseHeight = 20;\n  const firstWidth = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n  const firstPosStartX = Math.floor(rand() * (maxX - firstWidth));\n  const firstPosEndX = firstPosStartX + firstWidth;\n  platforms.push({\n    type: 'p',\n    height: baseHeight,\n    posStartX: firstPosStartX,\n    posEndX: firstPosEndX\n  });\n\n  let prev = platforms[0];\n\n  // Genera le piattaforme intermedie\n  for (let i = 1; i < N; i++) {\n    // Incremento verticale controllato\n    const verticalIncrement = Math.floor(rand() * (maxVertical - minVertical + 1)) + minVertical;\n    const newHeight = prev.height + verticalIncrement;\n    // Larghezza della nuova piattaforma\n    const width = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n    // Scegli gap e direzione (1 = a destra, -1 = a sinistra)\n    let gap = Math.floor(rand() * (maxGap - minGap + 1)) + minGap;\n    let direction = rand() < 0.5 ? 1 : -1;\n    let posStartX;\n\n    if (direction === 1) {\n      // Prova a posizionare a destra della precedente\n      if (prev.posEndX + gap + width <= maxX) {\n        posStartX = prev.posEndX + gap;\n      } else if (prev.posStartX - gap - width >= 0) {\n        // Se non c'è spazio a destra, prova a sinistra\n        direction = -1;\n        posStartX = prev.posStartX - gap - width;\n      } else {\n        // Forza il posizionamento in caso di spazio ristretto\n        posStartX = Math.max(0, maxX - width);\n      }\n    } else {\n      // Prova a posizionare a sinistra della precedente\n      if (prev.posStartX - gap - width >= 0) {\n        posStartX = prev.posStartX - gap - width;\n      } else if (prev.posEndX + gap + width <= maxX) {\n        // Se non c'è spazio a sinistra, prova a destra\n        direction = 1;\n        posStartX = prev.posEndX + gap;\n      } else {\n        posStartX = 0;\n      }\n    }\n    const posEndX = posStartX + width;\n\n    // Se è l'ultima piattaforma, forziamo il tipo \"T\" (la piattaforma bianca)\n    let type = (i === N ) ? \"T\" : \"p\";\n    // Per le intermedie, aggiungiamo la possibilità di avere spike (tipo \"s\")\n    if (type === \"p\" && rand() < 0.3) {\n      type = \"s\";\n    }\n\n    const platform = {\n      type,\n      height: newHeight,\n      posStartX,\n      posEndX,\n    };\n    platforms.push(platform);\n    prev = platform;\n  }\n  return platforms;\n}\nfunction EmuSchermo({ pressedButtons }) {\n  const ballSize = 4;\n  const horizontalAcceleration = 0.1;\n  const maxHorizontalSpeed = 1;\n  const friction = 0.2;\n  const jumpVelocity = 6;\n  const gravity = -0.5;\n  const [level, setLevel] = useState(1);\n  const [LEVEL, SETLEVEL] = useState(generateLevel(1));\n  const platformsRef = useRef(LEVEL);\n\n  useEffect(() => {\n    platformsRef.current = LEVEL;\n  }, [LEVEL]);\n\n  const [ball, setBall] = useState({\n    x: 2,\n    y: 0,\n    vx: 0,\n    vy: 0,\n  });\n\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n\n  const animationFrameId = useRef(null);\n\n  useEffect(() => {\n    const update = () => {\n      setBall((prev) => {\n        let { x, y, vx, vy } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione input orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) vx -= horizontalAcceleration;\n        if (currentPressedButtons[BUTTONS.RIGHT]) vx += horizontalAcceleration;\n\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          vx = vx > 0 ? Math.max(vx - friction, 0) : Math.min(vx + friction, 0);\n        }\n\n        vx = Math.min(Math.max(vx, -maxHorizontalSpeed), maxHorizontalSpeed);\n\n        // Salto solo se a terra o su piattaforma\n        const isOnGroundOrPlatform =\n          prev.y === 0 ||\n          platformsRef.current.some(p => {\n            const platformTop = p.height + 2;\n            const horizontalOverlap = (\n              prev.x <= p.posEndX &&\n              (prev.x + ballSize) >= p.posStartX\n            );\n            return prev.y === platformTop && horizontalOverlap;\n          });\n\n        if (currentPressedButtons[BUTTONS.A] && isOnGroundOrPlatform) {\n          vy = jumpVelocity;\n        }\n\n        vy += gravity;\n        let newY = y + vy;\n        let newX = x + vx;\n\n        // Collisioni con piattaforme\n        let collided = false;\n\n        platformsRef.current.forEach(platform => {\n          const platformTop = platform.height + 2; // Top della piattaforma (2% di spessore)\n          const platformBottom = platform.height;   // Base della piattaforma\n\n          // 1. Controllo overlap orizzontale\n          const horizontalOverlap = (\n            newX < platform.posEndX &&\n            (newX + ballSize) > platform.posStartX\n          );\n\n          // 2. Controllo overlap verticale\n          const verticalOverlap = (\n            newY <= platformTop &&\n            (newY + ballSize) >= platformBottom\n          );\n\n          // 3. Determinazione direzione collisione\n          if (horizontalOverlap && verticalOverlap) {\n            const prevBottom = prev.y + ballSize;\n            if (prevBottom <= platformBottom && vy > 0) {\n              // Collisione dal basso (salto contro piattaforma)\n              newY = platformBottom - ballSize;\n              vy = 0;\n            } else if (vy <= 0) {\n              // Collisione dall'alto (atterraggio su piattaforma)\n              newY = platformTop;\n              vy = 0;\n            }\n            collided = true;\n          }\n        });\n\n        // Collisione con il terreno solo se non abbiamo colliso con piattaforme\n        if (!collided && newY < 0) {\n          newY = 0;\n          vy = 0;\n        }\n\n        // Clamping orizzontale\n        newX = Math.max(0, Math.min(newX, 100 - ballSize));\n\n        platformsRef.current.forEach(platform => {\n          if (platform.type === \"s\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeTop = platform.height + 3;\n            const spikeBottom = platform.height;\n\n            const horizontalCollision = (\n              x + ballSize > spikeLeft &&\n              x < spikeRight\n            );\n\n            const verticalCollision = (\n              y  < spikeTop &&\n              y + ballSize  > spikeBottom &&\n              vy <= 0\n            );\n\n            if (horizontalCollision && verticalCollision) {\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n              SETLEVEL(generateLevel(level));\n            }\n          }\n          if (platform.type === \"T\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeTop = platform.height + 3;\n            const spikeBottom = platform.height +2 ;\n\n            const horizontalCollision = (\n              x + ballSize > spikeLeft &&\n              x < spikeRight\n            );\n\n            const verticalCollision = (\n              y < spikeTop &&\n              y + ballSize > spikeBottom &&\n              vy <= 0\n            );\n\n            if (horizontalCollision && verticalCollision) {\n              const newLevel = level + 1;\n              setLevel(newLevel);\n              SETLEVEL(generateLevel(newLevel)); // Aggiorna lo stato correttamente\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n            }\n          }\n        });\n        return { x: newX, y: newY, vx, vy };\n      });\n      animationFrameId.current = requestAnimationFrame(update);\n    };\n\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [level, ballSize, horizontalAcceleration, friction, maxHorizontalSpeed, jumpVelocity, gravity]);\n\n  return (\n    <div className=\"emu-container\">\n      <div\n        className=\"ball\"\n        style={{\n          left: `${ball.x}%`,\n          bottom: `${ball.y}%`,\n          width: `${ballSize}%`,\n          height: `${ballSize + 2}%`,\n        }}\n      ></div>\n\n      {LEVEL.map((item, i) => {\n        if (item.type === \"T\") {\n          return (\n            <div\n              key={i}\n              className=\"t-platform\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        } else if (item.type === \"p\") {\n          return (\n            <div\n              key={i}\n              className=\"platform\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        } else {\n          return (\n            <div\n              key={i}\n              className=\"spike\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        }\n      })}\n    </div>\n  );\n}\n\nexport default EmuSchermo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}