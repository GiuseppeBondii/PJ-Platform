{"ast":null,"code":"var _jsxFileName = \"/Users/giuseppebondi/Documents/GitHub/platform/src/components/EmuSchermo.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\nimport { GAME_LEVELS } from \"./Levels\"; // Importa i livelli dal file creato\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  UP: 5,\n  DOWN: 6,\n  LEFT: 7,\n  RIGHT: 8\n};\nconst LEVEL_TYPES = {\n  PLATFORM: \"platform\",\n  MOVING: \"moving\",\n  BOUNCE: \"bounce\",\n  ENEMY: \"enemy\",\n  COLLECTABLE: \"coin\",\n  FINISH: \"finish\",\n  SPIKE: \"spike\",\n  DISAPPEARING: \"disappear\"\n};\nfunction EmuSchermo({\n  pressedButtons\n}) {\n  _s();\n  var _GAME_LEVELS$currentL;\n  // Costanti di fisica espresse in percentuali\n  const ballSize = 5;\n  const horizontalAcceleration = 0.2;\n  const maxHorizontalSpeed = 2;\n  const friction = 0.1;\n  const jumpVelocity = 7;\n  const gravity = -0.5;\n  const bounceMultiplier = 1.5; // Moltiplicatore per piattaforme rimbalzanti\n\n  // Stato di gioco\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [gameState, setGameState] = useState({\n    lives: 3,\n    score: 0,\n    collectables: 0,\n    isGameOver: false,\n    isLevelComplete: false\n  });\n\n  // Array per tenere traccia degli oggetti collezionabili raccolti\n  const [collectedItems, setCollectedItems] = useState([]);\n\n  // Stato delle piattaforme che scompaiono\n  const [disappearingPlatforms, setDisappearingPlatforms] = useState({});\n\n  // Riferimento al timer per piattaforme che scompaiono\n  const disappearingTimersRef = useRef({});\n\n  // Stato della pallina\n  const [ball, setBall] = useState({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 0,\n    isOnGround: false,\n    isJumping: false\n  });\n\n  // Inizializza la posizione della pallina all'inizio del livello\n  useEffect(() => {\n    if (GAME_LEVELS[currentLevel]) {\n      const {\n        startPosition\n      } = GAME_LEVELS[currentLevel];\n      setBall(prev => ({\n        ...prev,\n        x: startPosition.x,\n        y: startPosition.y,\n        vx: 0,\n        vy: 0,\n        isOnGround: false,\n        isJumping: false\n      }));\n\n      // Resetta lo stato delle piattaforme che scompaiono\n      setDisappearingPlatforms({});\n\n      // Cancella i timer esistenti\n      Object.values(disappearingTimersRef.current).forEach(timer => clearTimeout(timer));\n      disappearingTimersRef.current = {};\n\n      // Resetta gli oggetti collezionabili raccolti\n      setCollectedItems([]);\n    }\n  }, [currentLevel]);\n\n  // Usiamo un ref per tenere traccia dell'ultimo valore di pressedButtons\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n\n  // Verifica se c'è una collisione con una piattaforma\n  const checkPlatformCollision = (x, y, vx, vy) => {\n    if (!GAME_LEVELS[currentLevel]) return {\n      collision: false\n    };\n    const elements = GAME_LEVELS[currentLevel].elements;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n\n      // Salta se la piattaforma è scomparsa\n      if (element.type === LEVEL_TYPES.DISAPPEARING && disappearingPlatforms[i]) {\n        continue;\n      }\n      if (element.type === LEVEL_TYPES.PLATFORM || element.type === LEVEL_TYPES.MOVING || element.type === LEVEL_TYPES.BOUNCE || element.type === LEVEL_TYPES.DISAPPEARING) {\n        // Ottieni posizione effettiva per piattaforme in movimento\n        let elementX = element.x;\n        let elementY = element.y;\n        if (element.type === LEVEL_TYPES.MOVING) {\n          const time = Date.now() / 1000;\n          const cycle = Math.sin(time * element.speed);\n          const offset = element.offset || 0;\n          elementX = element.x + element.moveX * cycle;\n          elementY = element.y + element.moveY * cycle;\n        }\n\n        // Controllo collisione\n        if (x < elementX + element.width && x + ballSize > elementX && y < elementY + element.height && y + ballSize > elementY) {\n          // Se stiamo cadendo e colpendo la piattaforma dall'alto\n          if (vy < 0 && y >= elementY + element.height - 1) {\n            // Fa scomparire la piattaforma se è di tipo DISAPPEARING\n            if (element.type === LEVEL_TYPES.DISAPPEARING && !disappearingPlatforms[i]) {\n              disappearingTimersRef.current[i] = setTimeout(() => {\n                setDisappearingPlatforms(prev => ({\n                  ...prev,\n                  [i]: true\n                }));\n              }, element.timeout || 1000);\n            }\n\n            // Rimbalza se la piattaforma è di tipo BOUNCE\n            if (element.type === LEVEL_TYPES.BOUNCE) {\n              return {\n                collision: true,\n                y: elementY + element.height,\n                vy: jumpVelocity * (element.power || bounceMultiplier),\n                isOnGround: false\n              };\n            }\n            return {\n              collision: true,\n              y: elementY + element.height,\n              vy: 0,\n              isOnGround: true\n            };\n          }\n\n          // Collisione laterale\n          if (vy >= 0) {\n            // Determina se la collisione è laterale o superiore\n            const fromLeft = x + ballSize - elementX;\n            const fromRight = elementX + element.width - x;\n            const fromTop = y - elementY - element.height;\n            if (fromTop < 0 && Math.min(fromLeft, fromRight) < Math.abs(fromTop)) {\n              if (fromLeft < fromRight) {\n                return {\n                  collision: true,\n                  x: elementX - ballSize,\n                  vx: 0\n                };\n              } else {\n                return {\n                  collision: true,\n                  x: elementX + element.width,\n                  vx: 0\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n    return {\n      collision: false\n    };\n  };\n\n  // Controlla se c'è una collisione con un oggetto collezionabile\n  const checkCollectableCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n    const elements = GAME_LEVELS[currentLevel].elements;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.type === LEVEL_TYPES.COLLECTABLE) {\n        // Salta se l'oggetto è già stato raccolto\n        if (collectedItems.includes(i)) continue;\n\n        // Controllo collisione (oggetto collezionabile è un punto)\n        const collectableSize = 5; // Dimensione approssimativa dell'oggetto\n        if (x < element.x + collectableSize && x + ballSize > element.x && y < element.y + collectableSize && y + ballSize > element.y) {\n          // Aggiorna lo stato di gioco\n          setGameState(prev => ({\n            ...prev,\n            score: prev.score + 100,\n            collectables: prev.collectables + 1\n          }));\n\n          // Aggiorna l'array degli oggetti raccolti\n          setCollectedItems(prev => [...prev, i]);\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // Controlla se c'è una collisione con un nemico o una punta\n  const checkHazardCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n    const elements = GAME_LEVELS[currentLevel].elements;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.type === LEVEL_TYPES.ENEMY || element.type === LEVEL_TYPES.SPIKE) {\n        let elementX = element.x;\n        let elementY = element.y;\n\n        // Aggiorna la posizione per nemici in movimento\n        if (element.type === LEVEL_TYPES.ENEMY && element.moveX) {\n          const time = Date.now() / 1000;\n          const cycle = Math.sin(time * element.speed);\n          elementX = element.x + element.moveX * cycle;\n        }\n\n        // Controllo collisione\n        if (x < elementX + element.width && x + ballSize > elementX && y < elementY + element.height && y + ballSize > elementY) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // Controlla se il giocatore ha raggiunto il traguardo\n  const checkFinishCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n    const elements = GAME_LEVELS[currentLevel].elements;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.type === LEVEL_TYPES.FINISH) {\n        const finishSize = 10; // Dimensione approssimativa del traguardo\n        if (x < element.x + finishSize && x + ballSize > element.x && y < element.y + finishSize && y + ballSize > element.y) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // Gestisce il completamento del livello\n  const completeLevel = () => {\n    // Verifica se ci sono altri livelli\n    if (currentLevel < GAME_LEVELS.length - 1) {\n      // Passa al livello successivo\n      setCurrentLevel(prev => prev + 1);\n    } else {\n      // Hai completato tutti i livelli\n      setGameState(prev => ({\n        ...prev,\n        isGameOver: true,\n        isLevelComplete: true\n      }));\n    }\n  };\n\n  // Gestisce la morte del giocatore\n  const playerDeath = () => {\n    // Riduce il numero di vite\n    setGameState(prev => {\n      const newLives = prev.lives - 1;\n\n      // Game over se non ci sono più vite\n      if (newLives <= 0) {\n        return {\n          ...prev,\n          lives: 0,\n          isGameOver: true\n        };\n      }\n      return {\n        ...prev,\n        lives: newLives\n      };\n    });\n\n    // Reimposta la posizione della pallina all'inizio del livello\n    if (GAME_LEVELS[currentLevel]) {\n      const {\n        startPosition\n      } = GAME_LEVELS[currentLevel];\n      setBall(prev => ({\n        ...prev,\n        x: startPosition.x,\n        y: startPosition.y,\n        vx: 0,\n        vy: 0,\n        isOnGround: false,\n        isJumping: false\n      }));\n    }\n  };\n\n  // Ciclo di animazione continuo con requestAnimationFrame\n  const animationFrameId = useRef(null);\n  useEffect(() => {\n    const update = () => {\n      // Salta l'aggiornamento se il gioco è in pausa o finito\n      if (gameState.isGameOver) {\n        return;\n      }\n      setBall(prev => {\n        let {\n          x,\n          y,\n          vx,\n          vy,\n          isOnGround,\n          isJumping\n        } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione dell'accelerazione orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) {\n          vx -= horizontalAcceleration;\n        }\n        if (currentPressedButtons[BUTTONS.RIGHT]) {\n          vx += horizontalAcceleration;\n        }\n\n        // Se non ci sono input orizzontali, applica attrito\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          // Applica attrito per rallentare gradualmente\n          if (vx > 0) {\n            vx = Math.max(vx - friction, 0);\n          } else if (vx < 0) {\n            vx = Math.min(vx + friction, 0);\n          }\n        }\n\n        // Limita la velocità orizzontale\n        if (vx > maxHorizontalSpeed) vx = maxHorizontalSpeed;\n        if (vx < -maxHorizontalSpeed) vx = -maxHorizontalSpeed;\n\n        // Gestione per il pulsante A (salto)\n        if (currentPressedButtons[BUTTONS.A] && isOnGround) {\n          vy = jumpVelocity;\n          isOnGround = false;\n          isJumping = true;\n        } else if (!currentPressedButtons[BUTTONS.A]) {\n          isJumping = false;\n        }\n\n        // Applica la gravità alla velocità verticale\n        vy += gravity;\n\n        // Aggiorna le posizioni\n        const newX = x + vx;\n        const newY = y + vy;\n\n        // Controlla collisioni con le piattaforme\n        const platformCollision = checkPlatformCollision(newX, newY, vx, vy);\n        if (platformCollision.collision) {\n          // Aggiorna posizione e velocità in base alla collisione\n          x = platformCollision.x !== undefined ? platformCollision.x : newX;\n          y = platformCollision.y !== undefined ? platformCollision.y : newY;\n          vx = platformCollision.vx !== undefined ? platformCollision.vx : vx;\n          vy = platformCollision.vy !== undefined ? platformCollision.vy : vy;\n          isOnGround = platformCollision.isOnGround !== undefined ? platformCollision.isOnGround : isOnGround;\n        } else {\n          // Nessuna collisione, aggiorna normalmente\n          x = newX;\n          y = newY;\n          isOnGround = false;\n        }\n\n        // Controlla se è stato raccolto un oggetto collezionabile\n        checkCollectableCollision(x, y);\n\n        // Controlla collisioni con nemici o punte\n        if (checkHazardCollision(x, y)) {\n          playerDeath();\n          return {\n            x,\n            y,\n            vx: 0,\n            vy: 0,\n            isOnGround: false,\n            isJumping: false\n          };\n        }\n\n        // Controlla se il giocatore ha raggiunto il traguardo\n        if (checkFinishCollision(x, y)) {\n          completeLevel();\n        }\n\n        // Controllo se il giocatore è caduto dal livello\n        if (y < -10) {\n          playerDeath();\n          return {\n            x,\n            y: 0,\n            vx: 0,\n            vy: 0,\n            isOnGround: false,\n            isJumping: false\n          };\n        }\n\n        // Clamping della posizione orizzontale nel container\n        if (x < 0) {\n          x = 0;\n          vx = 0;\n        }\n        if (x > 100 - ballSize) {\n          x = 100 - ballSize;\n          vx = 0;\n        }\n\n        // Gestione dei pulsanti START e SELECT\n        if (currentPressedButtons[BUTTONS.START]) {\n          // Reimposta il livello\n          if (GAME_LEVELS[currentLevel]) {\n            const {\n              startPosition\n            } = GAME_LEVELS[currentLevel];\n            return {\n              x: startPosition.x,\n              y: startPosition.y,\n              vx: 0,\n              vy: 0,\n              isOnGround: false,\n              isJumping: false\n            };\n          }\n        }\n        if (currentPressedButtons[BUTTONS.SELECT]) {\n          // Cambia il livello\n          setCurrentLevel(prev => (prev + 1) % GAME_LEVELS.length);\n        }\n\n        // Supporto per la pressione DOWN (abbassarsi o accelerare la caduta)\n        if (currentPressedButtons[BUTTONS.DOWN] && !isOnGround) {\n          vy -= 0.5; // Accelera la caduta\n        }\n        return {\n          x,\n          y,\n          vx,\n          vy,\n          isOnGround,\n          isJumping\n        };\n      });\n      animationFrameId.current = requestAnimationFrame(update);\n    };\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [currentLevel, gameState.isGameOver]);\n\n  // Renderizza il livello corrente\n  const renderLevel = () => {\n    if (!GAME_LEVELS[currentLevel]) return null;\n    const level = GAME_LEVELS[currentLevel];\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: level.elements.map((element, index) => {\n        // Salta se la piattaforma è scomparsa\n        if (element.type === LEVEL_TYPES.DISAPPEARING && disappearingPlatforms[index]) {\n          return null;\n        }\n\n        // Salta se l'oggetto collezionabile è stato raccolto\n        if (element.type === LEVEL_TYPES.COLLECTABLE && collectedItems.includes(index)) {\n          return null;\n        }\n\n        // Calcola la posizione per elementi in movimento\n        let elementX = element.x;\n        let elementY = element.y;\n        if (element.type === LEVEL_TYPES.MOVING) {\n          const time = Date.now() / 1000;\n          const cycle = Math.sin(time * element.speed);\n          const offset = element.offset || 0;\n          elementX = element.x + element.moveX * cycle;\n          elementY = element.y + element.moveY * cycle;\n        }\n\n        // Renderizza in base al tipo\n        switch (element.type) {\n          case LEVEL_TYPES.PLATFORM:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"platform\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 503,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.MOVING:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"platform moving\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 516,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.BOUNCE:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"platform bounce\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 529,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.DISAPPEARING:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"platform disappearing\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 542,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.ENEMY:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"enemy\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 555,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.SPIKE:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"spike\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: `${element.width}%`,\n                height: `${element.height}%`\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 568,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.COLLECTABLE:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"collectable\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: \"5%\",\n                height: \"5%\"\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 581,\n              columnNumber: 17\n            }, this);\n          case LEVEL_TYPES.FINISH:\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"finish\",\n              style: {\n                left: `${elementX}%`,\n                bottom: `${elementY}%`,\n                width: \"10%\",\n                height: \"10%\"\n              }\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 594,\n              columnNumber: 17\n            }, this);\n          default:\n            return null;\n        }\n      })\n    }, void 0, false);\n  };\n\n  // Renderizza l'interfaccia di gioco\n  const renderGameInterface = () => {\n    if (gameState.isGameOver) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-over\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: gameState.isLevelComplete ? \"Congratulazioni!\" : \"Game Over\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 618,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Punteggio: \", gameState.score]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 619,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Oggetti raccolti: \", gameState.collectables]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 620,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setCurrentLevel(0);\n            setGameState({\n              lives: 3,\n              score: 0,\n              collectables: 0,\n              isGameOver: false,\n              isLevelComplete: false\n            });\n          },\n          children: \"Ricomincia\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 621,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 617,\n        columnNumber: 9\n      }, this);\n    }\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Livello: \", currentLevel + 1]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 641,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Vite: \", gameState.lives]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 642,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Punteggio: \", gameState.score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 643,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 640,\n      columnNumber: 7\n    }, this);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"emu-container\",\n    style: {\n      backgroundColor: ((_GAME_LEVELS$currentL = GAME_LEVELS[currentLevel]) === null || _GAME_LEVELS$currentL === void 0 ? void 0 : _GAME_LEVELS$currentL.backgroundColor) || \"#87CEEB\"\n    },\n    children: [renderLevel(), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"ball\",\n      style: {\n        left: `${ball.x}%`,\n        bottom: `${ball.y}%`,\n        width: `${ballSize}%`,\n        height: `${ballSize}%`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 652,\n      columnNumber: 7\n    }, this), renderGameInterface()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 649,\n    columnNumber: 5\n  }, this);\n}\n_s(EmuSchermo, \"XxXNyaZUUSHnl8KvwD5VMOip40s=\");\n_c = EmuSchermo;\nexport default EmuSchermo;\nvar _c;\n$RefreshReg$(_c, \"EmuSchermo\");","map":{"version":3,"names":["React","useState","useEffect","useRef","GAME_LEVELS","jsxDEV","_jsxDEV","Fragment","_Fragment","BUTTONS","A","B","START","SELECT","UP","DOWN","LEFT","RIGHT","LEVEL_TYPES","PLATFORM","MOVING","BOUNCE","ENEMY","COLLECTABLE","FINISH","SPIKE","DISAPPEARING","EmuSchermo","pressedButtons","_s","_GAME_LEVELS$currentL","ballSize","horizontalAcceleration","maxHorizontalSpeed","friction","jumpVelocity","gravity","bounceMultiplier","currentLevel","setCurrentLevel","gameState","setGameState","lives","score","collectables","isGameOver","isLevelComplete","collectedItems","setCollectedItems","disappearingPlatforms","setDisappearingPlatforms","disappearingTimersRef","ball","setBall","x","y","vx","vy","isOnGround","isJumping","startPosition","prev","Object","values","current","forEach","timer","clearTimeout","pressedButtonsRef","checkPlatformCollision","collision","elements","i","length","element","type","elementX","elementY","time","Date","now","cycle","Math","sin","speed","offset","moveX","moveY","width","height","setTimeout","timeout","power","fromLeft","fromRight","fromTop","min","abs","checkCollectableCollision","includes","collectableSize","checkHazardCollision","checkFinishCollision","finishSize","completeLevel","playerDeath","newLives","animationFrameId","update","currentPressedButtons","max","newX","newY","platformCollision","undefined","requestAnimationFrame","cancelAnimationFrame","renderLevel","level","children","map","index","className","style","left","bottom","fileName","_jsxFileName","lineNumber","columnNumber","renderGameInterface","onClick","backgroundColor","_c","$RefreshReg$"],"sources":["/Users/giuseppebondi/Documents/GitHub/platform/src/components/EmuSchermo.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\nimport { GAME_LEVELS } from \"./Levels\"; // Importa i livelli dal file creato\n\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  UP: 5,\n  DOWN: 6,\n  LEFT: 7,\n  RIGHT: 8,\n};\n\nconst LEVEL_TYPES = {\n  PLATFORM: \"platform\",\n  MOVING: \"moving\",\n  BOUNCE: \"bounce\",\n  ENEMY: \"enemy\",\n  COLLECTABLE: \"coin\",\n  FINISH: \"finish\",\n  SPIKE: \"spike\",\n  DISAPPEARING: \"disappear\"\n};\n\nfunction EmuSchermo({ pressedButtons }) {\n  // Costanti di fisica espresse in percentuali\n  const ballSize = 5;\n  const horizontalAcceleration = 0.2;\n  const maxHorizontalSpeed = 2;\n  const friction = 0.1;\n  const jumpVelocity = 7;\n  const gravity = -0.5;\n  const bounceMultiplier = 1.5; // Moltiplicatore per piattaforme rimbalzanti\n\n  // Stato di gioco\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [gameState, setGameState] = useState({\n    lives: 3,\n    score: 0,\n    collectables: 0,\n    isGameOver: false,\n    isLevelComplete: false\n  });\n\n  // Array per tenere traccia degli oggetti collezionabili raccolti\n  const [collectedItems, setCollectedItems] = useState([]);\n  \n  // Stato delle piattaforme che scompaiono\n  const [disappearingPlatforms, setDisappearingPlatforms] = useState({});\n\n  // Riferimento al timer per piattaforme che scompaiono\n  const disappearingTimersRef = useRef({});\n\n  // Stato della pallina\n  const [ball, setBall] = useState({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 0,\n    isOnGround: false,\n    isJumping: false\n  });\n\n  // Inizializza la posizione della pallina all'inizio del livello\n  useEffect(() => {\n    if (GAME_LEVELS[currentLevel]) {\n      const { startPosition } = GAME_LEVELS[currentLevel];\n      setBall(prev => ({\n        ...prev,\n        x: startPosition.x,\n        y: startPosition.y,\n        vx: 0,\n        vy: 0,\n        isOnGround: false,\n        isJumping: false\n      }));\n      \n      // Resetta lo stato delle piattaforme che scompaiono\n      setDisappearingPlatforms({});\n      \n      // Cancella i timer esistenti\n      Object.values(disappearingTimersRef.current).forEach(timer => clearTimeout(timer));\n      disappearingTimersRef.current = {};\n      \n      // Resetta gli oggetti collezionabili raccolti\n      setCollectedItems([]);\n    }\n  }, [currentLevel]);\n\n  // Usiamo un ref per tenere traccia dell'ultimo valore di pressedButtons\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n\n  // Verifica se c'è una collisione con una piattaforma\n  const checkPlatformCollision = (x, y, vx, vy) => {\n    if (!GAME_LEVELS[currentLevel]) return { collision: false };\n\n    const elements = GAME_LEVELS[currentLevel].elements;\n    \n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      \n      // Salta se la piattaforma è scomparsa\n      if (element.type === LEVEL_TYPES.DISAPPEARING && disappearingPlatforms[i]) {\n        continue;\n      }\n      \n      if (element.type === LEVEL_TYPES.PLATFORM || \n          element.type === LEVEL_TYPES.MOVING || \n          element.type === LEVEL_TYPES.BOUNCE || \n          element.type === LEVEL_TYPES.DISAPPEARING) {\n        \n        // Ottieni posizione effettiva per piattaforme in movimento\n        let elementX = element.x;\n        let elementY = element.y;\n        \n        if (element.type === LEVEL_TYPES.MOVING) {\n          const time = Date.now() / 1000;\n          const cycle = Math.sin(time * element.speed);\n          const offset = element.offset || 0;\n          \n          elementX = element.x + element.moveX * cycle;\n          elementY = element.y + element.moveY * cycle;\n        }\n        \n        // Controllo collisione\n        if (x < elementX + element.width && \n            x + ballSize > elementX && \n            y < elementY + element.height && \n            y + ballSize > elementY) {\n          \n          // Se stiamo cadendo e colpendo la piattaforma dall'alto\n          if (vy < 0 && y >= elementY + element.height - 1) {\n            // Fa scomparire la piattaforma se è di tipo DISAPPEARING\n            if (element.type === LEVEL_TYPES.DISAPPEARING && !disappearingPlatforms[i]) {\n              disappearingTimersRef.current[i] = setTimeout(() => {\n                setDisappearingPlatforms(prev => ({ ...prev, [i]: true }));\n              }, element.timeout || 1000);\n            }\n            \n            // Rimbalza se la piattaforma è di tipo BOUNCE\n            if (element.type === LEVEL_TYPES.BOUNCE) {\n              return { \n                collision: true, \n                y: elementY + element.height, \n                vy: jumpVelocity * (element.power || bounceMultiplier),\n                isOnGround: false\n              };\n            }\n            \n            return { \n              collision: true, \n              y: elementY + element.height, \n              vy: 0,\n              isOnGround: true\n            };\n          }\n          \n          // Collisione laterale\n          if (vy >= 0) {\n            // Determina se la collisione è laterale o superiore\n            const fromLeft = x + ballSize - elementX;\n            const fromRight = elementX + element.width - x;\n            const fromTop = y - elementY - element.height;\n            \n            if (fromTop < 0 && Math.min(fromLeft, fromRight) < Math.abs(fromTop)) {\n              if (fromLeft < fromRight) {\n                return { collision: true, x: elementX - ballSize, vx: 0 };\n              } else {\n                return { collision: true, x: elementX + element.width, vx: 0 };\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    return { collision: false };\n  };\n\n  // Controlla se c'è una collisione con un oggetto collezionabile\n  const checkCollectableCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n\n    const elements = GAME_LEVELS[currentLevel].elements;\n    \n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      \n      if (element.type === LEVEL_TYPES.COLLECTABLE) {\n        // Salta se l'oggetto è già stato raccolto\n        if (collectedItems.includes(i)) continue;\n        \n        // Controllo collisione (oggetto collezionabile è un punto)\n        const collectableSize = 5; // Dimensione approssimativa dell'oggetto\n        if (x < element.x + collectableSize && \n            x + ballSize > element.x && \n            y < element.y + collectableSize && \n            y + ballSize > element.y) {\n          \n          // Aggiorna lo stato di gioco\n          setGameState(prev => ({\n            ...prev,\n            score: prev.score + 100,\n            collectables: prev.collectables + 1\n          }));\n          \n          // Aggiorna l'array degli oggetti raccolti\n          setCollectedItems(prev => [...prev, i]);\n          \n          return true;\n        }\n      }\n    }\n    \n    return false;\n  };\n\n  // Controlla se c'è una collisione con un nemico o una punta\n  const checkHazardCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n\n    const elements = GAME_LEVELS[currentLevel].elements;\n    \n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      \n      if (element.type === LEVEL_TYPES.ENEMY || element.type === LEVEL_TYPES.SPIKE) {\n        let elementX = element.x;\n        let elementY = element.y;\n        \n        // Aggiorna la posizione per nemici in movimento\n        if (element.type === LEVEL_TYPES.ENEMY && element.moveX) {\n          const time = Date.now() / 1000;\n          const cycle = Math.sin(time * element.speed);\n          elementX = element.x + element.moveX * cycle;\n        }\n        \n        // Controllo collisione\n        if (x < elementX + element.width && \n            x + ballSize > elementX && \n            y < elementY + element.height && \n            y + ballSize > elementY) {\n          \n          return true;\n        }\n      }\n    }\n    \n    return false;\n  };\n\n  // Controlla se il giocatore ha raggiunto il traguardo\n  const checkFinishCollision = (x, y) => {\n    if (!GAME_LEVELS[currentLevel]) return false;\n\n    const elements = GAME_LEVELS[currentLevel].elements;\n    \n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      \n      if (element.type === LEVEL_TYPES.FINISH) {\n        const finishSize = 10; // Dimensione approssimativa del traguardo\n        if (x < element.x + finishSize && \n            x + ballSize > element.x && \n            y < element.y + finishSize && \n            y + ballSize > element.y) {\n          \n          return true;\n        }\n      }\n    }\n    \n    return false;\n  };\n\n  // Gestisce il completamento del livello\n  const completeLevel = () => {\n    // Verifica se ci sono altri livelli\n    if (currentLevel < GAME_LEVELS.length - 1) {\n      // Passa al livello successivo\n      setCurrentLevel(prev => prev + 1);\n    } else {\n      // Hai completato tutti i livelli\n      setGameState(prev => ({\n        ...prev,\n        isGameOver: true,\n        isLevelComplete: true\n      }));\n    }\n  };\n\n  // Gestisce la morte del giocatore\n  const playerDeath = () => {\n    // Riduce il numero di vite\n    setGameState(prev => {\n      const newLives = prev.lives - 1;\n      \n      // Game over se non ci sono più vite\n      if (newLives <= 0) {\n        return {\n          ...prev,\n          lives: 0,\n          isGameOver: true\n        };\n      }\n      \n      return {\n        ...prev,\n        lives: newLives\n      };\n    });\n    \n    // Reimposta la posizione della pallina all'inizio del livello\n    if (GAME_LEVELS[currentLevel]) {\n      const { startPosition } = GAME_LEVELS[currentLevel];\n      setBall(prev => ({\n        ...prev,\n        x: startPosition.x,\n        y: startPosition.y,\n        vx: 0,\n        vy: 0,\n        isOnGround: false,\n        isJumping: false\n      }));\n    }\n  };\n\n  // Ciclo di animazione continuo con requestAnimationFrame\n  const animationFrameId = useRef(null);\n  useEffect(() => {\n    const update = () => {\n      // Salta l'aggiornamento se il gioco è in pausa o finito\n      if (gameState.isGameOver) {\n        return;\n      }\n      \n      setBall(prev => {\n        let { x, y, vx, vy, isOnGround, isJumping } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione dell'accelerazione orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) {\n          vx -= horizontalAcceleration;\n        } \n        if (currentPressedButtons[BUTTONS.RIGHT]) {\n          vx += horizontalAcceleration;\n        } \n        \n        // Se non ci sono input orizzontali, applica attrito\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          // Applica attrito per rallentare gradualmente\n          if (vx > 0) {\n            vx = Math.max(vx - friction, 0);\n          } else if (vx < 0) {\n            vx = Math.min(vx + friction, 0);\n          }\n        }\n\n        // Limita la velocità orizzontale\n        if (vx > maxHorizontalSpeed) vx = maxHorizontalSpeed;\n        if (vx < -maxHorizontalSpeed) vx = -maxHorizontalSpeed;\n\n        // Gestione per il pulsante A (salto)\n        if (currentPressedButtons[BUTTONS.A] && isOnGround) {\n          vy = jumpVelocity;\n          isOnGround = false;\n          isJumping = true;\n        } else if (!currentPressedButtons[BUTTONS.A]) {\n          isJumping = false;\n        }\n\n        // Applica la gravità alla velocità verticale\n        vy += gravity;\n\n        // Aggiorna le posizioni\n        const newX = x + vx;\n        const newY = y + vy;\n        \n        // Controlla collisioni con le piattaforme\n        const platformCollision = checkPlatformCollision(newX, newY, vx, vy);\n        \n        if (platformCollision.collision) {\n          // Aggiorna posizione e velocità in base alla collisione\n          x = platformCollision.x !== undefined ? platformCollision.x : newX;\n          y = platformCollision.y !== undefined ? platformCollision.y : newY;\n          vx = platformCollision.vx !== undefined ? platformCollision.vx : vx;\n          vy = platformCollision.vy !== undefined ? platformCollision.vy : vy;\n          isOnGround = platformCollision.isOnGround !== undefined ? platformCollision.isOnGround : isOnGround;\n        } else {\n          // Nessuna collisione, aggiorna normalmente\n          x = newX;\n          y = newY;\n          isOnGround = false;\n        }\n        \n        // Controlla se è stato raccolto un oggetto collezionabile\n        checkCollectableCollision(x, y);\n        \n        // Controlla collisioni con nemici o punte\n        if (checkHazardCollision(x, y)) {\n          playerDeath();\n          return { x, y, vx: 0, vy: 0, isOnGround: false, isJumping: false };\n        }\n        \n        // Controlla se il giocatore ha raggiunto il traguardo\n        if (checkFinishCollision(x, y)) {\n          completeLevel();\n        }\n        \n        // Controllo se il giocatore è caduto dal livello\n        if (y < -10) {\n          playerDeath();\n          return { x, y: 0, vx: 0, vy: 0, isOnGround: false, isJumping: false };\n        }\n\n        // Clamping della posizione orizzontale nel container\n        if (x < 0) {\n          x = 0;\n          vx = 0;\n        }\n        if (x > 100 - ballSize) {\n          x = 100 - ballSize;\n          vx = 0;\n        }\n\n        // Gestione dei pulsanti START e SELECT\n        if (currentPressedButtons[BUTTONS.START]) {\n          // Reimposta il livello\n          if (GAME_LEVELS[currentLevel]) {\n            const { startPosition } = GAME_LEVELS[currentLevel];\n            return {\n              x: startPosition.x,\n              y: startPosition.y,\n              vx: 0,\n              vy: 0,\n              isOnGround: false,\n              isJumping: false\n            };\n          }\n        }\n\n        if (currentPressedButtons[BUTTONS.SELECT]) {\n          // Cambia il livello\n          setCurrentLevel(prev => (prev + 1) % GAME_LEVELS.length);\n        }\n\n        // Supporto per la pressione DOWN (abbassarsi o accelerare la caduta)\n        if (currentPressedButtons[BUTTONS.DOWN] && !isOnGround) {\n          vy -= 0.5; // Accelera la caduta\n        }\n\n        return { x, y, vx, vy, isOnGround, isJumping };\n      });\n      \n      animationFrameId.current = requestAnimationFrame(update);\n    };\n\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [currentLevel, gameState.isGameOver]);\n\n  // Renderizza il livello corrente\n  const renderLevel = () => {\n    if (!GAME_LEVELS[currentLevel]) return null;\n    \n    const level = GAME_LEVELS[currentLevel];\n    \n    return (\n      <>\n        {level.elements.map((element, index) => {\n          // Salta se la piattaforma è scomparsa\n          if (element.type === LEVEL_TYPES.DISAPPEARING && disappearingPlatforms[index]) {\n            return null;\n          }\n          \n          // Salta se l'oggetto collezionabile è stato raccolto\n          if (element.type === LEVEL_TYPES.COLLECTABLE && collectedItems.includes(index)) {\n            return null;\n          }\n          \n          // Calcola la posizione per elementi in movimento\n          let elementX = element.x;\n          let elementY = element.y;\n          \n          if (element.type === LEVEL_TYPES.MOVING) {\n            const time = Date.now() / 1000;\n            const cycle = Math.sin(time * element.speed);\n            const offset = element.offset || 0;\n            \n            elementX = element.x + element.moveX * cycle;\n            elementY = element.y + element.moveY * cycle;\n          }\n          \n          // Renderizza in base al tipo\n          switch(element.type) {\n            case LEVEL_TYPES.PLATFORM:\n              return (\n                <div\n                  key={index}\n                  className=\"platform\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.MOVING:\n              return (\n                <div\n                  key={index}\n                  className=\"platform moving\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.BOUNCE:\n              return (\n                <div\n                  key={index}\n                  className=\"platform bounce\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.DISAPPEARING:\n              return (\n                <div\n                  key={index}\n                  className=\"platform disappearing\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.ENEMY:\n              return (\n                <div\n                  key={index}\n                  className=\"enemy\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.SPIKE:\n              return (\n                <div\n                  key={index}\n                  className=\"spike\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: `${element.width}%`,\n                    height: `${element.height}%`\n                  }}\n                />\n              );\n            case LEVEL_TYPES.COLLECTABLE:\n              return (\n                <div\n                  key={index}\n                  className=\"collectable\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: \"5%\",\n                    height: \"5%\"\n                  }}\n                />\n              );\n            case LEVEL_TYPES.FINISH:\n              return (\n                <div\n                  key={index}\n                  className=\"finish\"\n                  style={{\n                    left: `${elementX}%`,\n                    bottom: `${elementY}%`,\n                    width: \"10%\",\n                    height: \"10%\"\n                  }}\n                />\n              );\n            default:\n              return null;\n          }\n        })}\n      </>\n    );\n  };\n\n  // Renderizza l'interfaccia di gioco\n  const renderGameInterface = () => {\n    if (gameState.isGameOver) {\n      return (\n        <div className=\"game-over\">\n          <h2>{gameState.isLevelComplete ? \"Congratulazioni!\" : \"Game Over\"}</h2>\n          <p>Punteggio: {gameState.score}</p>\n          <p>Oggetti raccolti: {gameState.collectables}</p>\n          <button \n            onClick={() => {\n              setCurrentLevel(0);\n              setGameState({\n                lives: 3,\n                score: 0,\n                collectables: 0,\n                isGameOver: false,\n                isLevelComplete: false\n              });\n            }}\n          >\n            Ricomincia\n          </button>\n        </div>\n      );\n    }\n    \n    return (\n      <div className=\"game-info\">\n        <div>Livello: {currentLevel + 1}</div>\n        <div>Vite: {gameState.lives}</div>\n        <div>Punteggio: {gameState.score}</div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"emu-container\" style={{ backgroundColor: GAME_LEVELS[currentLevel]?.backgroundColor || \"#87CEEB\" }}>\n      {renderLevel()}\n      \n      <div\n        className=\"ball\"\n        style={{\n          left: `${ball.x}%`,\n          bottom: `${ball.y}%`,\n          width: `${ballSize}%`,\n          height: `${ballSize}%`\n        }}\n      ></div>\n      \n      {renderGameInterface()}\n    </div>\n  );\n}\n\nexport default EmuSchermo;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}