{"ast":null,"code":"var _jsxFileName = \"/Users/giuseppebondi/Documents/GitHub/PJ-Platform/src/components/EmuSchermo.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst maxHorizontalSpeed = 1.1;\nconst jumpVelocity = 5;\nconst gravity = -0.5;\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  LEFT: 7,\n  RIGHT: 8\n};\n\n// Parametri per la generazione\nconst screenHeight = 80; // Altezza massima dello schermo\nconst maxX = 100; // Larghezza massima orizzontale\nconst minWidth = 10;\nconst maxWidth = 30;\nconst minVertical = 10;\nconst maxVertical = 20;\nconst marginSafety = 1; // Margine di sicurezza orizzontale per il salto\n\n// Parametri per la generazione pseudo-casuale\n\nfunction createSeededRandom(seed) {\n  const a = Math.floor(Math.random() * 10000000000);\n  const c = Math.floor(Math.random() * 10000000000);\n  const m = 2 ** 32;\n  let state = seed;\n  return function () {\n    state = (a * state + c) % m;\n    return state / m;\n  };\n}\n\n// Funzione che calcola il tempo di volo disponibile per un salto data la differenza verticale dy\nfunction getFlightTime(dy) {\n  // Se il target è sopra (dy > 0) il tempo di volo è minore\n  if (dy > 0) {\n    // Risolve: 0.5*gravity*t^2 + jumpVelocity*t - dy = 0\n    // Poiché gravity è negativo, usiamo la formula corretta per ottenere il tempo positivo\n    return (jumpVelocity + Math.sqrt(jumpVelocity * jumpVelocity + -2 * gravity * dy)) / -gravity;\n  } else {\n    // Se il target è allo stesso livello o più in basso, consideriamo il tempo d'aria massimo (salto completo)\n    return 2 * jumpVelocity / -gravity;\n  }\n}\n\n// Calcola la distanza orizzontale massima raggiungibile per una data differenza verticale dy\nfunction getMaxHorizontalDistance(dy) {\n  const t = getFlightTime(dy);\n  return maxHorizontalSpeed * t;\n}\nfunction generateLevel(seed) {\n  const rand = createSeededRandom(seed);\n  const platforms = [];\n\n  // Genera la piattaforma di partenza (base)\n  const baseHeight = 15;\n  const firstWidth = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n  const firstPosStartX = Math.floor(rand() * (maxX - firstWidth));\n  const firstPosEndX = firstPosStartX + firstWidth;\n  platforms.push({\n    type: 'p',\n    height: baseHeight,\n    posStartX: firstPosStartX,\n    posEndX: firstPosEndX\n  });\n  let prev = platforms[0];\n\n  // Genera piattaforme intermedie fino a rimanere entro screenHeight\n  // L'ultima piattaforma verrà forzata ad essere il traguardo (T)\n  while (true) {\n    // Scegli un incremento verticale che non superi l'altezza massima dello schermo\n    const verticalIncrement = Math.floor(rand() * (maxVertical - minVertical + 1)) + minVertical;\n    const newHeight = prev.height + verticalIncrement;\n    if (newHeight > screenHeight - 10) {\n      // Se il prossimo salto supererebbe quasi lo screenHeight, usciamo dal ciclo.\n      break;\n    }\n\n    // Calcola la distanza massima orizzontale raggiungibile per questo salto\n    const maxReach = getMaxHorizontalDistance(verticalIncrement) - marginSafety;\n\n    // Per sicurezza, limitiamo il gap tra le piattaforme a un valore ragionevole (almeno 2 e al massimo quanto raggiungibile o un valore fisso)\n    const gap = Math.floor(Math.min(rand() * (maxReach - 2) + 2, 13 // oppure si può usare 13 se si preferisce una soglia fissa\n    ));\n\n    // Scegli casualmente la direzione: 1 = a destra, -1 = a sinistra\n    let direction = rand() < 0.5 ? 1 : -1;\n    let posStartX;\n    if (direction === 1) {\n      // Prova a posizionare a destra della precedente piattaforma\n      if (prev.posEndX + gap + minWidth <= maxX) {\n        posStartX = prev.posEndX + gap;\n      } else if (prev.posStartX - gap - minWidth >= 0) {\n        // Se non c'è spazio a destra, prova a sinistra\n        direction = -1;\n        posStartX = prev.posStartX - gap - minWidth;\n      } else {\n        // Forza il posizionamento in caso di spazio ristretto\n        posStartX = Math.max(0, maxX - minWidth);\n      }\n    } else {\n      // Prova a posizionare a sinistra della precedente\n      if (prev.posStartX - gap - minWidth >= 0) {\n        posStartX = prev.posStartX - gap - minWidth;\n      } else if (prev.posEndX + gap + minWidth <= maxX) {\n        // Se non c'è spazio a sinistra, prova a destra\n        direction = 1;\n        posStartX = prev.posEndX + gap;\n      } else {\n        posStartX = 0;\n      }\n    }\n\n    // La larghezza della piattaforma la scegliamo casualmente entro i limiti, senza superare il bordo\n    const width = Math.min(Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth, maxX - posStartX);\n    const posEndX = posStartX + width;\n\n    // Determina il tipo: di default è \"p\" (hazard), ma c'è una possibilità del 20% di aggiungere spike (tipo \"s\")\n    let type = \"p\";\n    if (rand() < 0.3 + seed / 50) {\n      type = \"s\";\n    }\n    const platform = {\n      type,\n      height: newHeight,\n      posStartX,\n      posEndX\n    };\n    platforms.push(platform);\n    prev = platform;\n  }\n\n  // Aggiungi la piattaforma finale \"T\" (traguardo) in una posizione raggiungibile dall'ultima piattaforma\n  // Per farlo, scegliamo un incremento verticale che faccia rimanere il traguardo entro lo screenHeight\n  const remainingVertical = screenHeight - prev.height;\n  // Se remainingVertical è troppo piccolo, possiamo impostare un piccolo incremento\n  const finalVerticalIncrement = remainingVertical > minVertical ? Math.floor(rand() * (Math.min(maxVertical, remainingVertical) - minVertical + 1)) + minVertical : remainingVertical;\n  const newHeight = prev.height + finalVerticalIncrement;\n  const maxReach = getMaxHorizontalDistance(finalVerticalIncrement) - marginSafety;\n  const gap = Math.floor(Math.min(rand() * (maxReach - 2) + 2, 13));\n  let direction = rand() < 0.5 ? 1 : -1;\n  let posStartX;\n  if (direction === 1) {\n    if (prev.posEndX + gap + minWidth <= maxX) {\n      posStartX = prev.posEndX + gap;\n    } else if (prev.posStartX - gap - minWidth >= 0) {\n      direction = -1;\n      posStartX = prev.posStartX - gap - minWidth;\n    } else {\n      posStartX = Math.max(0, maxX - minWidth);\n    }\n  } else {\n    if (prev.posStartX - gap - minWidth >= 0) {\n      posStartX = prev.posStartX - gap - minWidth;\n    } else if (prev.posEndX + gap + minWidth <= maxX) {\n      direction = 1;\n      posStartX = prev.posEndX + gap;\n    } else {\n      posStartX = 0;\n    }\n  }\n  const width = Math.min(Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth, maxX - posStartX);\n  const posEndX = posStartX + width;\n\n  // La piattaforma finale è il traguardo \"T\"\n  platforms.push({\n    type: \"T\",\n    height: newHeight,\n    posStartX,\n    posEndX\n  });\n  return platforms;\n}\nfunction EmuSchermo({\n  pressedButtons\n}) {\n  _s();\n  const ballSize = 4;\n  const horizontalAcceleration = 0.2;\n  const maxHorizontalSpeed = 1.2;\n  const friction = 0.1;\n  const jumpVelocity = 6;\n  const gravity = -0.5;\n\n  // Stato di gioco: \"countdown\", \"playing\", \"gameOver\", \"SlotTime\"\n  const [gameState, setGameState] = useState(\"countdown\");\n  const [countdown, setCountdown] = useState(3);\n  const [timeLeft, setTimeLeft] = useState(30);\n  const [record, setRecord] = useState(0);\n  const [timeSlot, setTimeSlot] = useState(0);\n  const [level, setLevel] = useState(9);\n  const [LEVEL, SETLEVEL] = useState(generateLevel(9));\n  const platformsRef = useRef(LEVEL);\n  useEffect(() => {\n    platformsRef.current = LEVEL;\n  }, [LEVEL]);\n  const [ball, setBall] = useState({\n    x: 2,\n    y: 0,\n    vx: 0,\n    vy: 0\n  });\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n  const animationFrameId = useRef(null);\n\n  // Countdown iniziale di 3 secondi\n  useEffect(() => {\n    if (gameState === \"countdown\") {\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            setGameState(\"playing\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(countdownInterval);\n    }\n  }, [gameState]);\n\n  // Timer di gioco: decrementa ogni secondo durante il gioco\n  useEffect(() => {\n    if (gameState === \"playing\") {\n      const timerInterval = setInterval(() => {\n        setTimeLeft(prev => {\n          if (prev <= 1) {\n            clearInterval(timerInterval);\n            setGameState(\"gameOver\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timerInterval);\n    }\n  }, [gameState]);\n  useEffect(() => {\n    if (gameState === \"slotTime\") {\n      const timerInterval = setInterval(() => {\n        setTimeLeft(prev => {\n          if (prev <= 1) {\n            clearInterval(timerInterval);\n            setGameState(\"gameOver\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timerInterval);\n    }\n  }, [gameState]);\n\n  // Loop di aggiornamento del gioco (solo se in stato \"playing\")\n  useEffect(() => {\n    if (gameState !== \"playing\") return;\n    const update = () => {\n      setBall(prev => {\n        let {\n          x,\n          y,\n          vx,\n          vy\n        } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione input orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) vx -= horizontalAcceleration;\n        if (currentPressedButtons[BUTTONS.RIGHT]) vx += horizontalAcceleration;\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          vx = vx > 0 ? Math.max(vx - friction, 0) : Math.min(vx + friction, 0);\n        }\n        vx = Math.min(Math.max(vx, -maxHorizontalSpeed), maxHorizontalSpeed);\n\n        // Controllo per permettere il salto (a terra o su piattaforma)\n        const isOnGroundOrPlatform = y === 0 || platformsRef.current.some(p => {\n          const platformTop = p.height + 2;\n          const horizontalOverlap = x <= p.posEndX && x + ballSize >= p.posStartX;\n          return y === platformTop && horizontalOverlap;\n        });\n        if (currentPressedButtons[BUTTONS.A] && isOnGroundOrPlatform) {\n          vy = jumpVelocity;\n        }\n        vy += gravity;\n        let newY = y + vy;\n        let newX = x + vx;\n\n        // Collisione base con piattaforme (aterraggio/scontro)\n        let collided = false;\n        platformsRef.current.forEach(platform => {\n          const platformTop = platform.height + 2;\n          const platformBottom = platform.height;\n          const horizontalOverlap = newX < platform.posEndX && newX + ballSize > platform.posStartX;\n          const verticalOverlap = newY <= platformTop && newY + ballSize >= platformBottom;\n          if (horizontalOverlap && verticalOverlap) {\n            const prevBottom = y + ballSize;\n            if (prevBottom <= platformBottom && vy > 0) {\n              // Salto contro la piattaforma\n              newY = platformBottom - ballSize;\n              vy = 0;\n            } else if (vy <= 0) {\n              // Atterraggio sulla piattaforma\n              newY = platformTop;\n              vy = 0;\n            }\n            collided = true;\n          }\n        });\n        if (!collided && newY < 0) {\n          newY = 0;\n          vy = 0;\n        }\n        newX = Math.max(0, Math.min(newX, 100 - ballSize));\n\n        // Gestione collisione con spike (\"s\") e traguardo (\"T\")\n        for (const platform of platformsRef.current) {\n          if (platform.type === \"s\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeBottom = platform.height;\n            const spikeTop = platform.height + 3;\n            const horizontalCollision = x + ballSize > spikeLeft && x < spikeRight;\n            const verticalCollision = y < spikeTop && y + ballSize > spikeBottom; //tolto vy<=0 \n            if (horizontalCollision && verticalCollision) {\n              setTimeLeft(prev => prev - 5);\n              platform.type = \"p\";\n              break;\n            }\n          } else if (platform.type === \"T\") {\n            const goalLeft = platform.posStartX;\n            const goalRight = platform.posEndX;\n            const goalBottom = platform.height;\n            const goalTop = platform.height + 3;\n            const horizontalCollision = x + ballSize > goalLeft && x < goalRight;\n            const verticalCollision = y < goalTop && y + ballSize > goalBottom; //tolto vy<=0 \n            if (horizontalCollision && verticalCollision) {\n              setTimeLeft(prev => prev + 10);\n              if (level % 10 === 0) {\n                setGameState(\"slotTime\");\n                setTimeSlot(timeLeft);\n              }\n              const newLevel = level + 1;\n              setLevel(newLevel);\n              SETLEVEL(generateLevel(newLevel));\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n              break;\n            }\n          }\n        }\n        return {\n          x: newX,\n          y: newY,\n          vx,\n          vy\n        };\n      });\n      animationFrameId.current = requestAnimationFrame(update);\n    };\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [gameState, level, ballSize, horizontalAcceleration, friction, maxHorizontalSpeed, jumpVelocity, gravity]);\n\n  // Funzione per ripartire la partita (Play Again)\n  const handlePlayAgain = () => {\n    setLevel(1);\n    SETLEVEL(generateLevel(1));\n    setBall({\n      x: 2,\n      y: 0,\n      vx: 0,\n      vy: 0\n    });\n    setTimeLeft(30);\n    setCountdown(3);\n    setGameState(\"countdown\");\n  };\n  useEffect(() => {\n    if (gameState === \"gameOver\") {\n      const storedRecord = localStorage.getItem(\"record\") ? parseInt(localStorage.getItem(\"record\"), 10) : 0;\n      if (level > storedRecord) {\n        localStorage.setItem(\"record\", level);\n        setRecord(level);\n      } else {\n        setRecord(storedRecord);\n      }\n    }\n  }, [gameState, level]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"emu-container\",\n    children: [gameState === \"countdown\" && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"countdown-overlay\",\n      children: /*#__PURE__*/_jsxDEV(\"h1\", {\n        children: countdown\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 438,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 437,\n      columnNumber: 9\n    }, this), gameState === \"gameOver\" && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"gameover-overlay\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Game Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 445,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Livello raggiunto: \", level]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 446,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Record: \", record]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 447,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"playAgainButton\",\n        onClick: handlePlayAgain,\n        children: \"Play Again\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 448,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 444,\n      columnNumber: 9\n    }, this), gameState === \"playing\" && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"hud\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Time: \", timeLeft]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 455,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Level: \", level]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 456,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 454,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"ball\",\n      style: {\n        left: `${ball.x}%`,\n        bottom: `${ball.y}%`,\n        width: `${ballSize}%`,\n        height: `${ballSize + 2}%`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 460,\n      columnNumber: 7\n    }, this), LEVEL.map((item, i) => {\n      if (item.type === \"T\") {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"t-platform\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 473,\n          columnNumber: 13\n        }, this);\n      } else if (item.type === \"p\") {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"platform\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 486,\n          columnNumber: 13\n        }, this);\n      } else {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"spike\",\n          style: {\n            left: `${item.posStartX}%`,\n            width: `${item.posEndX - item.posStartX}%`,\n            bottom: `${item.height}%`,\n            height: \"2%\"\n          }\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 499,\n          columnNumber: 13\n        }, this);\n      }\n    })]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 434,\n    columnNumber: 5\n  }, this);\n}\n_s(EmuSchermo, \"fts1JR7FJCb+AltzdOoO1p2rtTw=\");\n_c = EmuSchermo;\nexport default EmuSchermo;\nvar _c;\n$RefreshReg$(_c, \"EmuSchermo\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","maxHorizontalSpeed","jumpVelocity","gravity","BUTTONS","A","B","START","SELECT","LEFT","RIGHT","screenHeight","maxX","minWidth","maxWidth","minVertical","maxVertical","marginSafety","createSeededRandom","seed","a","Math","floor","random","c","m","state","getFlightTime","dy","sqrt","getMaxHorizontalDistance","t","generateLevel","rand","platforms","baseHeight","firstWidth","firstPosStartX","firstPosEndX","push","type","height","posStartX","posEndX","prev","verticalIncrement","newHeight","maxReach","gap","min","direction","max","width","platform","remainingVertical","finalVerticalIncrement","EmuSchermo","pressedButtons","_s","ballSize","horizontalAcceleration","friction","gameState","setGameState","countdown","setCountdown","timeLeft","setTimeLeft","record","setRecord","timeSlot","setTimeSlot","level","setLevel","LEVEL","SETLEVEL","platformsRef","current","ball","setBall","x","y","vx","vy","pressedButtonsRef","animationFrameId","countdownInterval","setInterval","clearInterval","timerInterval","update","currentPressedButtons","isOnGroundOrPlatform","some","p","platformTop","horizontalOverlap","newY","newX","collided","forEach","platformBottom","verticalOverlap","prevBottom","spikeLeft","spikeRight","spikeBottom","spikeTop","horizontalCollision","verticalCollision","goalLeft","goalRight","goalBottom","goalTop","newLevel","requestAnimationFrame","cancelAnimationFrame","handlePlayAgain","storedRecord","localStorage","getItem","parseInt","setItem","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","style","left","bottom","map","item","i","_c","$RefreshReg$"],"sources":["/Users/giuseppebondi/Documents/GitHub/PJ-Platform/src/components/EmuSchermo.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport \"./EmuSchermo.css\";\n\nconst maxHorizontalSpeed = 1.1;\nconst jumpVelocity = 5;\nconst gravity = -0.5;\n\nconst BUTTONS = {\n  A: 1,\n  B: 2,\n  START: 3,\n  SELECT: 4,\n  LEFT: 7,\n  RIGHT: 8,\n};\n\n// Parametri per la generazione\nconst screenHeight = 80; // Altezza massima dello schermo\nconst maxX = 100;        // Larghezza massima orizzontale\nconst minWidth = 10;\nconst maxWidth = 30;\nconst minVertical = 10;\nconst maxVertical = 20;\nconst marginSafety = 1;  // Margine di sicurezza orizzontale per il salto\n\n// Parametri per la generazione pseudo-casuale\n\n\nfunction createSeededRandom(seed) {\n  const a = Math.floor(Math.random() * 10000000000);\n  const c = Math.floor(Math.random() * 10000000000);\n  const m = 2 ** 32;\n  let state = seed;\n  return function () {\n    state = (a * state + c) % m;\n    return state / m;\n  };\n}\n\n// Funzione che calcola il tempo di volo disponibile per un salto data la differenza verticale dy\nfunction getFlightTime(dy) {\n  // Se il target è sopra (dy > 0) il tempo di volo è minore\n  if (dy > 0) {\n    // Risolve: 0.5*gravity*t^2 + jumpVelocity*t - dy = 0\n    // Poiché gravity è negativo, usiamo la formula corretta per ottenere il tempo positivo\n    return (jumpVelocity + Math.sqrt(jumpVelocity * jumpVelocity + (-2 * gravity * dy))) / (-gravity);\n  } else {\n    // Se il target è allo stesso livello o più in basso, consideriamo il tempo d'aria massimo (salto completo)\n    return 2 * jumpVelocity / (-gravity);\n  }\n}\n\n// Calcola la distanza orizzontale massima raggiungibile per una data differenza verticale dy\nfunction getMaxHorizontalDistance(dy) {\n  const t = getFlightTime(dy);\n  return maxHorizontalSpeed * t;\n}\n\nfunction generateLevel(seed) {\n  const rand = createSeededRandom(seed);\n  const platforms = [];\n\n  // Genera la piattaforma di partenza (base)\n  const baseHeight = 15;\n  const firstWidth = Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth;\n  const firstPosStartX = Math.floor(rand() * (maxX - firstWidth));\n  const firstPosEndX = firstPosStartX + firstWidth;\n  platforms.push({\n    type: 'p',\n    height: baseHeight,\n    posStartX: firstPosStartX,\n    posEndX: firstPosEndX\n  });\n\n  let prev = platforms[0];\n\n  // Genera piattaforme intermedie fino a rimanere entro screenHeight\n  // L'ultima piattaforma verrà forzata ad essere il traguardo (T)\n  while (true) {\n    // Scegli un incremento verticale che non superi l'altezza massima dello schermo\n    const verticalIncrement = Math.floor(rand() * (maxVertical - minVertical + 1)) + minVertical;\n    const newHeight = prev.height + verticalIncrement;\n    if (newHeight > screenHeight - 10) { \n      // Se il prossimo salto supererebbe quasi lo screenHeight, usciamo dal ciclo.\n      break;\n    }\n    \n    // Calcola la distanza massima orizzontale raggiungibile per questo salto\n    const maxReach = getMaxHorizontalDistance(verticalIncrement) - marginSafety;\n    \n    // Per sicurezza, limitiamo il gap tra le piattaforme a un valore ragionevole (almeno 2 e al massimo quanto raggiungibile o un valore fisso)\n    const gap = Math.floor(Math.min(\n      (rand() * (maxReach - 2) + 2),\n      13  // oppure si può usare 13 se si preferisce una soglia fissa\n    ));\n    \n    // Scegli casualmente la direzione: 1 = a destra, -1 = a sinistra\n    let direction = rand() < 0.5 ? 1 : -1;\n    let posStartX;\n    \n    if (direction === 1) {\n      // Prova a posizionare a destra della precedente piattaforma\n      if (prev.posEndX + gap + minWidth <= maxX) {\n        posStartX = prev.posEndX + gap;\n      } else if (prev.posStartX - gap - minWidth >= 0) {\n        // Se non c'è spazio a destra, prova a sinistra\n        direction = -1;\n        posStartX = prev.posStartX - gap - minWidth;\n      } else {\n        // Forza il posizionamento in caso di spazio ristretto\n        posStartX = Math.max(0, maxX - minWidth);\n      }\n    } else {\n      // Prova a posizionare a sinistra della precedente\n      if (prev.posStartX - gap - minWidth >= 0) {\n        posStartX = prev.posStartX - gap - minWidth;\n      } else if (prev.posEndX + gap + minWidth <= maxX) {\n        // Se non c'è spazio a sinistra, prova a destra\n        direction = 1;\n        posStartX = prev.posEndX + gap;\n      } else {\n        posStartX = 0;\n      }\n    }\n    \n    // La larghezza della piattaforma la scegliamo casualmente entro i limiti, senza superare il bordo\n    const width = Math.min(\n      Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth,\n      maxX - posStartX\n    );\n    const posEndX = posStartX + width;\n    \n    // Determina il tipo: di default è \"p\" (hazard), ma c'è una possibilità del 20% di aggiungere spike (tipo \"s\")\n    let type = \"p\";\n    if (rand() < 0.3 + (seed / 50)) {\n      type = \"s\";\n    }\n    \n    const platform = {\n      type,\n      height: newHeight,\n      posStartX,\n      posEndX\n    };\n    platforms.push(platform);\n    prev = platform;\n  }\n  \n  // Aggiungi la piattaforma finale \"T\" (traguardo) in una posizione raggiungibile dall'ultima piattaforma\n  // Per farlo, scegliamo un incremento verticale che faccia rimanere il traguardo entro lo screenHeight\n  const remainingVertical = screenHeight - prev.height;\n  // Se remainingVertical è troppo piccolo, possiamo impostare un piccolo incremento\n  const finalVerticalIncrement = remainingVertical > minVertical ? \n    Math.floor(rand() * (Math.min(maxVertical, remainingVertical) - minVertical + 1)) + minVertical :\n    remainingVertical;\n  const newHeight = prev.height + finalVerticalIncrement;\n  const maxReach = getMaxHorizontalDistance(finalVerticalIncrement) - marginSafety;\n  const gap = Math.floor(Math.min((rand() * (maxReach - 2) + 2), 13));\n  let direction = rand() < 0.5 ? 1 : -1;\n  let posStartX;\n  \n  if (direction === 1) {\n    if (prev.posEndX + gap + minWidth <= maxX) {\n      posStartX = prev.posEndX + gap;\n    } else if (prev.posStartX - gap - minWidth >= 0) {\n      direction = -1;\n      posStartX = prev.posStartX - gap - minWidth;\n    } else {\n      posStartX = Math.max(0, maxX - minWidth);\n    }\n  } else {\n    if (prev.posStartX - gap - minWidth >= 0) {\n      posStartX = prev.posStartX - gap - minWidth;\n    } else if (prev.posEndX + gap + minWidth <= maxX) {\n      direction = 1;\n      posStartX = prev.posEndX + gap;\n    } else {\n      posStartX = 0;\n    }\n  }\n  \n  const width = Math.min(\n    Math.floor(rand() * (maxWidth - minWidth + 1)) + minWidth,\n    maxX - posStartX\n  );\n  const posEndX = posStartX + width;\n  \n  // La piattaforma finale è il traguardo \"T\"\n  platforms.push({\n    type: \"T\",\n    height: newHeight,\n    posStartX,\n    posEndX\n  });\n  \n  return platforms;\n}\n\n\n\nfunction EmuSchermo({ pressedButtons }) {\n  const ballSize = 4;\n  const horizontalAcceleration = 0.2;\n  const maxHorizontalSpeed = 1.2;\n  const friction = 0.1;\n  const jumpVelocity = 6;\n  const gravity = -0.5;\n\n  // Stato di gioco: \"countdown\", \"playing\", \"gameOver\", \"SlotTime\"\n  const [gameState, setGameState] = useState(\"countdown\");\n  const [countdown, setCountdown] = useState(3);\n  const [timeLeft, setTimeLeft] = useState(30);\n  const [record, setRecord] = useState(0);\n  const [timeSlot, setTimeSlot] = useState(0)\n\n\n  const [level, setLevel] = useState(9);\n  const [LEVEL, SETLEVEL] = useState(generateLevel(9));\n  const platformsRef = useRef(LEVEL);\n  useEffect(() => {\n    platformsRef.current = LEVEL;\n  }, [LEVEL]);\n\n  const [ball, setBall] = useState({\n    x: 2,\n    y: 0,\n    vx: 0,\n    vy: 0,\n  });\n\n  const pressedButtonsRef = useRef(pressedButtons);\n  useEffect(() => {\n    pressedButtonsRef.current = pressedButtons;\n  }, [pressedButtons]);\n\n  const animationFrameId = useRef(null);\n\n\n  \n\n  // Countdown iniziale di 3 secondi\n  useEffect(() => {\n    if (gameState === \"countdown\") {\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            setGameState(\"playing\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(countdownInterval);\n    }\n  }, [gameState]);\n\n  // Timer di gioco: decrementa ogni secondo durante il gioco\n  useEffect(() => {\n    if (gameState === \"playing\") {\n      const timerInterval = setInterval(() => {\n        setTimeLeft(prev => {\n          if (prev <= 1) {\n            clearInterval(timerInterval);\n            setGameState(\"gameOver\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timerInterval);\n    }\n  }, [gameState]);\n\n\n  useEffect(() => {\n    if (gameState === \"slotTime\") {\n      const timerInterval = setInterval(() => {\n        setTimeLeft(prev => {\n          if (prev <= 1) {\n            clearInterval(timerInterval);\n            setGameState(\"gameOver\");\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      return () => clearInterval(timerInterval);\n    }\n  }, [gameState]);\n\n  // Loop di aggiornamento del gioco (solo se in stato \"playing\")\n  useEffect(() => {\n    if (gameState !== \"playing\" ) return;\n    \n    const update = () => {\n      setBall((prev) => {\n        let { x, y, vx, vy } = prev;\n        const currentPressedButtons = pressedButtonsRef.current || {};\n\n        // Gestione input orizzontale\n        if (currentPressedButtons[BUTTONS.LEFT]) vx -= horizontalAcceleration;\n        if (currentPressedButtons[BUTTONS.RIGHT]) vx += horizontalAcceleration;\n        if (!currentPressedButtons[BUTTONS.LEFT] && !currentPressedButtons[BUTTONS.RIGHT]) {\n          vx = vx > 0 ? Math.max(vx - friction, 0) : Math.min(vx + friction, 0);\n        }\n        vx = Math.min(Math.max(vx, -maxHorizontalSpeed), maxHorizontalSpeed);\n\n        // Controllo per permettere il salto (a terra o su piattaforma)\n        const isOnGroundOrPlatform =\n          y === 0 ||\n          platformsRef.current.some(p => {\n            const platformTop = p.height + 2;\n            const horizontalOverlap = (\n              x <= p.posEndX &&\n              (x + ballSize) >= p.posStartX\n            );\n            return y === platformTop && horizontalOverlap;\n          });\n\n        if (currentPressedButtons[BUTTONS.A] && isOnGroundOrPlatform) {\n          vy = jumpVelocity;\n        }\n\n        vy += gravity;\n        let newY = y + vy;\n        let newX = x + vx;\n\n        // Collisione base con piattaforme (aterraggio/scontro)\n        let collided = false;\n        platformsRef.current.forEach(platform => {\n          const platformTop = platform.height + 2;\n          const platformBottom = platform.height;\n          const horizontalOverlap = (\n            newX < platform.posEndX &&\n            (newX + ballSize) > platform.posStartX\n          );\n          const verticalOverlap = (\n            newY <= platformTop &&\n            (newY + ballSize) >= platformBottom\n          );\n          if (horizontalOverlap && verticalOverlap) {\n            const prevBottom = y + ballSize;\n            if (prevBottom <= platformBottom && vy > 0) {\n              // Salto contro la piattaforma\n              newY = platformBottom - ballSize;\n              vy = 0;\n            } else if (vy <= 0) {\n              // Atterraggio sulla piattaforma\n              newY = platformTop;\n              vy = 0;\n            }\n            collided = true;\n          }\n        });\n        if (!collided && newY < 0) {\n          newY = 0;\n          vy = 0;\n        }\n        newX = Math.max(0, Math.min(newX, 100 - ballSize));\n\n        // Gestione collisione con spike (\"s\") e traguardo (\"T\")\n        for (const platform of platformsRef.current) {\n          if (platform.type === \"s\") {\n            const spikeLeft = platform.posStartX;\n            const spikeRight = platform.posEndX;\n            const spikeBottom = platform.height;\n            const spikeTop = platform.height + 3;\n            const horizontalCollision = (x + ballSize > spikeLeft && x < spikeRight);\n            const verticalCollision = (y < spikeTop && y + ballSize > spikeBottom ); //tolto vy<=0 \n            if (horizontalCollision && verticalCollision) {\n              setTimeLeft(prev => prev - 5);\n              platform.type = \"p\";\n              break;\n            }\n          } else if (platform.type === \"T\") {\n            const goalLeft = platform.posStartX;\n            const goalRight = platform.posEndX;\n            const goalBottom = platform.height;\n            const goalTop = platform.height + 3;\n            const horizontalCollision = (x + ballSize > goalLeft && x < goalRight);\n            const verticalCollision = (y < goalTop && y + ballSize > goalBottom ); //tolto vy<=0 \n            if (horizontalCollision && verticalCollision) {\n              setTimeLeft(prev => prev + 10);\n\n              if (level % 10 === 0){\n                setGameState(\"slotTime\");\n                setTimeSlot(timeLeft);\n              }\n              const newLevel = level + 1;\n              setLevel(newLevel);\n              SETLEVEL(generateLevel(newLevel));\n              newX = 2;\n              newY = 0;\n              vx = 0;\n              vy = 0;\n              break;\n            }\n          }\n        }\n\n        return { x: newX, y: newY, vx, vy };\n      });\n      animationFrameId.current = requestAnimationFrame(update);\n    };\n\n    animationFrameId.current = requestAnimationFrame(update);\n    return () => cancelAnimationFrame(animationFrameId.current);\n  }, [gameState, level, ballSize, horizontalAcceleration, friction, maxHorizontalSpeed, jumpVelocity, gravity]);\n\n  // Funzione per ripartire la partita (Play Again)\n  const handlePlayAgain = () => {\n    setLevel(1);\n    SETLEVEL(generateLevel(1));\n    setBall({ x: 2, y: 0, vx: 0, vy: 0 });\n    setTimeLeft(30);\n    setCountdown(3);\n    setGameState(\"countdown\");\n  };\n\n  useEffect(() => {\n    if (gameState === \"gameOver\") {\n      const storedRecord = localStorage.getItem(\"record\") ? parseInt(localStorage.getItem(\"record\"), 10) : 0;\n      if (level > storedRecord) {\n        localStorage.setItem(\"record\", level);\n        setRecord(level);\n      } else {\n        setRecord(storedRecord);\n      }\n    }\n  }, [gameState, level]);\n\n  return (\n    <div className=\"emu-container\">\n      {/* Overlay per il countdown iniziale */}\n      {gameState === \"countdown\" && (\n        <div className=\"countdown-overlay\">\n          <h1>{countdown}</h1>\n        </div>\n      )}\n\n    {/* Overlay Game Over */}\n    {gameState === \"gameOver\" && (\n        <div className=\"gameover-overlay\">\n          <h1>Game Over</h1>\n          <p>Livello raggiunto: {level}</p>\n          <p>Record: {record}</p>\n          <button className=\"playAgainButton\" onClick={handlePlayAgain}>Play Again</button>\n        </div>\n      )}\n\n      {/* HUD durante il gioco */}\n      {gameState === \"playing\" && (\n        <div className=\"hud\">\n          <p>Time: {timeLeft}</p>\n          <p>Level: {level}</p>\n        </div>\n      )}\n\n      <div\n        className=\"ball\"\n        style={{\n          left: `${ball.x}%`,\n          bottom: `${ball.y}%`,\n          width: `${ballSize}%`,\n          height: `${ballSize + 2}%`,\n        }}\n      ></div>\n\n      {LEVEL.map((item, i) => {\n        if (item.type === \"T\") {\n          return (\n            <div\n              key={i}\n              className=\"t-platform\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        } else if (item.type === \"p\") {\n          return (\n            <div\n              key={i}\n              className=\"platform\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        } else {\n          return (\n            <div\n              key={i}\n              className=\"spike\"\n              style={{\n                left: `${item.posStartX}%`,\n                width: `${item.posEndX - item.posStartX}%`,\n                bottom: `${item.height}%`,\n                height: \"2%\",\n              }}\n            />\n          );\n        }\n      })}\n    </div>\n  );\n}\n\n\nexport default EmuSchermo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}